using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Roslynjector.Generator;

[Generator]
public sealed class RoslynjectorGenerator : IIncrementalGenerator
{
    private const string AddSingleton = "AddSingleton";
    private const string AddTransient = "AddTransient";
    private const string AddScoped = "AddScoped";
    
    // Simple records the generator uses internally
    private abstract record BindingInfo(ITypeSymbol Service, ServiceLifetime Lifetime);
    private sealed record ImplBindingInfo(ITypeSymbol Service, ITypeSymbol Impl, ServiceLifetime Lifetime)
        : BindingInfo(Service, Lifetime)
    {
        public override string ToString() => $"{Lifetime} {Service} -> {Impl}";
    }
    private sealed record FactoryBindingInfo(ITypeSymbol Service, string FactoryText, ServiceLifetime Lifetime)
        : BindingInfo(Service, Lifetime)
    {
        public override string ToString() => $"{Lifetime} {Service} = factory({FactoryText})";
    }

    private enum ServiceLifetime
    {
        Singleton, 
        Transient,
        Scoped,
    }
    
    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        var registrations = ctx.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) =>
                node is InvocationExpressionSyntax inv
                && inv.Expression is MemberAccessExpressionSyntax mae
                && mae.Name is IdentifierNameSyntax id
                && (id.Identifier.Text is AddSingleton or AddTransient or AddScoped),

            transform: static (ctx, _) =>
            {
                var inv = (InvocationExpressionSyntax)ctx.Node;
                var model = ctx.SemanticModel;

                // What method is actually being called?
                var symbol = model.GetSymbolInfo(inv).Symbol as IMethodSymbol;
                if (symbol is null) 
                    return default;
                

                // We care about the generic 2-arg forms: AddX<TService,TImpl>()
                if (symbol.TypeArguments.Length == 2)
                {
                    var svc = symbol.TypeArguments[0] as INamedTypeSymbol;
                    var impl = symbol.TypeArguments[1] as INamedTypeSymbol;
                    
                    if (svc is null || impl is null) 
                        return default(BindingInfo?);

                    var lifetime = symbol.Name == AddSingleton 
                        ? ServiceLifetime.Singleton 
                        : ServiceLifetime.Transient;
                    
                    return new ImplBindingInfo(svc, impl, lifetime);
                }

                // Factory overloads: AddX<TService>(Func<IServiceProvider,TService> factory)
                if (symbol.TypeArguments.Length == 1
                    && inv.ArgumentList.Arguments.Count == 1)
                {
                    var svc = symbol.TypeArguments[0] as INamedTypeSymbol;
                    var arg = inv.ArgumentList.Arguments[0];
                    // We'll preserve the lambda text for the MVP
                    var factoryText = arg.ToFullString();
                    var lifetime = symbol.Name == AddSingleton 
                        ? ServiceLifetime.Singleton 
                        : ServiceLifetime.Transient;
                    
                    return new FactoryBindingInfo(svc!, factoryText, lifetime);
                }

                return default;
            })
            .Where(static b => b is not null)!
            .Select(static (b, _) => b!);

        var all = registrations.Collect();

        // For now, just emit a file that lists what we found.
        ctx.RegisterSourceOutput(all, static (spc, regs) =>
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("namespace Roslynjector.Debug { public static class RegDump { public static string[] Items => new string[] {");

            foreach (var r in regs)
                sb.AppendLine($"\"{r}\",");

            sb.AppendLine("}; } }");
            spc.AddSource("RegDump.g.cs", sb.ToString());
        });
    }
}