using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Roslynjector.Generator;

[Generator]
public sealed class RoslynjectorGenerator : IIncrementalGenerator
{
    private const string AddSingleton = "AddSingleton";
    private const string AddTransient = "AddTransient";
    private const string AddScoped = "AddScoped";
    
    // Simple records the generator uses internally
    private abstract record BindingInfo(
        ITypeSymbol Service, 
        ServiceLifetime Lifetime);
    
    private sealed record ImplBindingInfo(
        ITypeSymbol Service, 
        ITypeSymbol Impl, 
        ServiceLifetime Lifetime)
        : BindingInfo(
            Service, 
            Lifetime)
    {
        public override string ToString() => $"{Lifetime} {Service} -> {Impl}";
    }
    
    private sealed record FactoryBindingInfo(
        ITypeSymbol Service, 
        string FactoryText, 
        ServiceLifetime Lifetime)
        : BindingInfo(
            Service, 
            Lifetime)
    {
        public override string ToString() => $"{Lifetime} {Service} = factory({FactoryText})";
    }

    private enum ServiceLifetime
    {
        Singleton, 
        Transient,
        Scoped,
    }
    
    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        var regs = ctx.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => IsAddCallCandidate(node),
                static (context, _) => TransformAddCall(context)
            )
            .Where(static x => x is not null)!
            .Select(static (x, _) => x!)
            .Collect();

        // Debug dump so you can see matches immediately
        ctx.RegisterSourceOutput(regs, static (spc, list) =>
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("namespace Roslynjector.Debug { public static class RegDump { public static string[] Items => new string[] {");
            
            foreach (var r in list)
            {
                sb.AppendLine($"\"{r}\",");
            }
            
            sb.AppendLine("}; } }");
            spc.AddSource("RegDump.g.cs", sb.ToString());
        });
    }
    
    // ---------- helpers ----------
    private static bool IsAddCallCandidate(SyntaxNode node)
    {
        if (node is not InvocationExpressionSyntax inv) 
            return false;

        // Normal:   services.AddSingleton(...)
        if (inv.Expression is MemberAccessExpressionSyntax memberAccessExpressionSyntax)
        {
            var name = memberAccessExpressionSyntax.Name switch
            {
                GenericNameSyntax genericNameSyntax => genericNameSyntax.Identifier.ValueText,
                IdentifierNameSyntax identifierNameSyntax => identifierNameSyntax.Identifier.ValueText,
                _ => null
            };
            return name is AddSingleton or AddTransient or AddScoped;
        }

        // Conditional access: services?.AddSingleton(...)
        if (inv.Expression is MemberBindingExpressionSyntax { Name: SimpleNameSyntax simpleNameSyntax })
        {
            var id = simpleNameSyntax switch
            {
                GenericNameSyntax genericNameSyntax => genericNameSyntax.Identifier.ValueText,
                IdentifierNameSyntax identifierNameSyntax => identifierNameSyntax.Identifier.ValueText,
                _ => null
            };
            return id is AddSingleton or AddTransient or AddScoped;
        }

        return false;
    }

    private static BindingInfo? TransformAddCall(GeneratorSyntaxContext context)
    {
        var inv = (InvocationExpressionSyntax)context.Node;
        var model = context.SemanticModel;

        if (model.GetSymbolInfo(inv).Symbol is not IMethodSymbol methodSymbol) 
            return null;

        var lifetime = methodSymbol.Name switch
        {
            AddSingleton => ServiceLifetime.Singleton,
            AddScoped => ServiceLifetime.Scoped,
            _ => ServiceLifetime.Transient
        };

        // CASE 1: Generic impl-based: AddX<TService,TImpl>()
        if (methodSymbol.TypeArguments.Length == 2)
        {
            if (methodSymbol.TypeArguments[0] is not INamedTypeSymbol service 
                || methodSymbol.TypeArguments[1] is not INamedTypeSymbol implementation) 
                return null;
            
            return new ImplBindingInfo(service, implementation, lifetime);
        }

        // CASE 2: Generic factory: AddX<TService>(Func<IServiceProvider,TService> factory)
        if (methodSymbol.TypeArguments.Length == 1 
            && inv.ArgumentList.Arguments.Count == 1)
        {
            if (methodSymbol.TypeArguments[0] is not INamedTypeSymbol service) 
                return null;
            
            var factoryText = inv.ArgumentList.Arguments[0].ToFullString();
            return new FactoryBindingInfo(service, factoryText, lifetime);
        }

        // CASE 3: Non-generic impl-based: AddX(typeof(Svc), typeof(Impl))
        if (methodSymbol.TypeArguments.Length == 0 && inv.ArgumentList.Arguments.Count == 2)
        {
            var argument0 = inv.ArgumentList.Arguments[0].Expression;
            var argument1 = inv.ArgumentList.Arguments[1].Expression;

            if (argument0 is TypeOfExpressionSyntax typeOfExpressionSyntax0 
                && argument1 is TypeOfExpressionSyntax typeOfExpressionSyntax1)
            {
                var service = model.GetTypeInfo(typeOfExpressionSyntax0.Type).Type as INamedTypeSymbol;
                var implementation = model.GetTypeInfo(typeOfExpressionSyntax1.Type).Type as INamedTypeSymbol;
                
                if (service is not null && implementation is not null)
                    return new ImplBindingInfo(service, implementation, lifetime);
            }
        }

        // CASE 4: Non-generic factory: AddX(typeof(Svc), factory)
        if (methodSymbol.TypeArguments.Length == 0 && inv.ArgumentList.Arguments.Count == 2)
        {
            var argument0 = inv.ArgumentList.Arguments[0].Expression;
            var argument1 = inv.ArgumentList.Arguments[1];

            if (argument0 is not TypeOfExpressionSyntax t0) 
                return null;

            if (model.GetTypeInfo(t0.Type).Type is not INamedTypeSymbol service) 
                return null;
                
            var factoryText = argument1.ToFullString();
            return new FactoryBindingInfo(service, factoryText, lifetime);
        }

        return null;
    }
}