using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Roslynjector.Generator;

[Generator]
public sealed class RoslynjectorGenerator : IIncrementalGenerator
{
    private const string AddSingleton = "AddSingleton";
    private const string AddTransient = "AddTransient";
    private const string AddScoped = "AddScoped";
    
    // Simple records the generator uses internally
    private abstract record BindingInfo(ITypeSymbol Service, ServiceLifetime Lifetime);
    private sealed record ImplBindingInfo(ITypeSymbol Service, ITypeSymbol Impl, ServiceLifetime Lifetime)
        : BindingInfo(Service, Lifetime)
    {
        public override string ToString() => $"{Lifetime} {Service} -> {Impl}";
    }
    private sealed record FactoryBindingInfo(ITypeSymbol Service, string FactoryText, ServiceLifetime Lifetime)
        : BindingInfo(Service, Lifetime)
    {
        public override string ToString() => $"{Lifetime} {Service} = factory({FactoryText})";
    }

    private enum ServiceLifetime
    {
        Singleton, 
        Transient,
        Scoped,
    }
    
    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        var regs = ctx.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => IsAddCallCandidate(node),
                static (context, _) => TransformAddCall(context)
            )
            .Where(static x => x is not null)!
            .Select(static (x, _) => x!)
            .Collect();

        // Debug dump so you can see matches immediately
        ctx.RegisterSourceOutput(regs, static (spc, list) =>
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("namespace Roslynjector.Debug { public static class RegDump { public static string[] Items => new string[] {");
            
            foreach (var r in list)
            {
                sb.AppendLine($"\"{r}\",");
            }
            
            sb.AppendLine("}; } }");
            spc.AddSource("RegDump.g.cs", sb.ToString());
        });
    }
    
    // ---------- helpers ----------

    private static bool IsAddCallCandidate(SyntaxNode node)
    {
        if (node is not InvocationExpressionSyntax inv) 
            return false;

        // Normal:   services.AddSingleton(...)
        if (inv.Expression is MemberAccessExpressionSyntax mae)
        {
            var name = mae.Name switch
            {
                GenericNameSyntax g => g.Identifier.ValueText,
                IdentifierNameSyntax i => i.Identifier.ValueText,
                _ => null
            };
            return name is AddSingleton or AddTransient or AddScoped;
        }

        // Conditional access: services?.AddSingleton(...)
        if (inv.Expression is MemberBindingExpressionSyntax mbs 
            && mbs.Name is SimpleNameSyntax sn)
        {
            var id = sn switch
            {
                GenericNameSyntax g => g.Identifier.ValueText,
                IdentifierNameSyntax i => i.Identifier.ValueText,
                _ => null
            };
            return id is AddSingleton or AddTransient or AddScoped;
        }

        return false;
    }

    private static BindingInfo? TransformAddCall(GeneratorSyntaxContext context)
    {
        var inv = (InvocationExpressionSyntax)context.Node;
        var model = context.SemanticModel;

        var sym = model.GetSymbolInfo(inv).Symbol as IMethodSymbol;
        if (sym is null) 
            return null;

        var lifetime = sym.Name switch
        {
            AddSingleton => ServiceLifetime.Singleton,
            AddScoped => ServiceLifetime.Scoped,
            _ => ServiceLifetime.Transient
        };

        // CASE 1: Generic impl-based: AddX<TService,TImpl>()
        if (sym.TypeArguments.Length == 2)
        {
            var svc = sym.TypeArguments[0] as INamedTypeSymbol;
            var impl = sym.TypeArguments[1] as INamedTypeSymbol;
            if (svc is null || impl is null) 
                return null;
            
            return new ImplBindingInfo(svc, impl, lifetime);
        }

        // CASE 2: Generic factory: AddX<TService>(Func<IServiceProvider,TService> factory)
        if (sym.TypeArguments.Length == 1 && inv.ArgumentList.Arguments.Count == 1)
        {
            var svc = sym.TypeArguments[0] as INamedTypeSymbol;
            if (svc is null) 
                return null;
            
            var factoryText = inv.ArgumentList.Arguments[0].ToFullString();
            return new FactoryBindingInfo(svc, factoryText, lifetime);
        }

        // CASE 3: Non-generic impl-based: AddX(typeof(Svc), typeof(Impl))
        if (sym.TypeArguments.Length == 0 && inv.ArgumentList.Arguments.Count == 2)
        {
            var argument0 = inv.ArgumentList.Arguments[0].Expression;
            var argument1 = inv.ArgumentList.Arguments[1].Expression;

            if (argument0 is TypeOfExpressionSyntax typeOfExpressionSyntax0 
                && argument1 is TypeOfExpressionSyntax typeOfExpressionSyntax1)
            {
                var svc = model.GetTypeInfo(typeOfExpressionSyntax0.Type).Type as INamedTypeSymbol;
                var impl = model.GetTypeInfo(typeOfExpressionSyntax1.Type).Type as INamedTypeSymbol;
                
                if (svc is not null && impl is not null)
                    return new ImplBindingInfo(svc, impl, lifetime);
            }
        }

        // CASE 4: Non-generic factory: AddX(typeof(Svc), factory)
        if (sym.TypeArguments.Length == 0 && inv.ArgumentList.Arguments.Count == 2)
        {
            var argument0 = inv.ArgumentList.Arguments[0].Expression;
            var argument1 = inv.ArgumentList.Arguments[1];

            if (argument0 is not TypeOfExpressionSyntax t0) 
                return null;
            
            var svc = model.GetTypeInfo(t0.Type).Type as INamedTypeSymbol;
            if (svc is null) 
                return null;
                
            var factoryText = argument1.ToFullString();
            return new FactoryBindingInfo(svc, factoryText, lifetime);
        }

        return null;
    }
}